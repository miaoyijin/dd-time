###select 方式

a)  内核/用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销；

b)  select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件


c)  select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO，
那么之后再次select调用还是会将这些文件描述符通知进程


大概流程：：select，poll是基于轮询实现的，将fd_set从用户空间复制到内核空间，然后让内核空间以poll机制来进行轮询，
一旦有其中一个fd对应的设备活跃了，那么就把整个fd_set返回给客户端（复制到用户空间），再由客户端来轮询每个fd的，
找出发生了IO事件的fd




###epoll
a）【我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点
，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个rdllist双向链表，
用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个rdllist双向链表里有没有数据即可。有数据就返回】
简单一句话：在内核中申请链一块地址用户保存红黑树，这样不用每次传递了。

b)  红黑树方便添加和删除

c)  就绪时只需要返回就绪的事件链表




