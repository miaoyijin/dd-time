1:explain查看查询的字段,
避免 SELECT *，需要什么数据，就查询对应的字段。
合理使用索引（下文介绍）。如：为排序、分组字段建立索引，避免 filesort 的出现
使用覆盖索引

2：索引使用
不适合使用索引的场景
1) 频繁更新的字段

2) where 条件中用不到的字段

3) 表记录太少

4) 经常增删改的表

5) 字段的值的差异性不大或重复性高
6）不要对索引列进行任何操作（计算、函数、类型转换）



3：分库分表&读写分离

4：数据库性能调优
1）Innodb_buffer_pool_size 设置
2）数据预热


5）调大排序内存
即一遍扫描数据后将select需要的列数据以及排序的列数据都取出来，这样就不需要进行第二遍扫描了，当然内存不足时也会使用磁盘临时文件进行外排。

MySQL根据max_length_for_sort_data来判断排序时使用一遍扫描还是两遍扫描。
如果需要的列数据一行可以放入max_length_for_sort_data则使用一遍扫描否则使用两遍>扫描

MySQL根据sort_buffer_size来判断是否使用磁盘临时文件，如果需要排序的数据能放入sort_buffer_size则无需使用磁盘临时文件，
此时explain只会输出using filesort 否则需要使用磁盘临时文件explain会输出using temporary（零时表）;using filesort
使用零时表存储数据，在用内存部分拍排序。

6：show profile 分析数据

7:es 优化




8:MySQL支持两种方式的排序,filesort和index,
index效率高,MySQL扫描索引本身完成排序。
filesort方式效率较低

order by 满足两种情况下,会使用index方式排序

1.order by 语句使用索引最左前列
2.使用where子句与order by子句条件组合满足索引最左前列
filesort有两种算法-双路排序和单路排序

双路排序,MySQL4.1之前是使用双路排序,字面意思就是两次扫描磁盘,最终得到数据,读取行指针和order by列,对他们进行排序,然后扫描已经排序好的列表,按照列表中的值重新从列表中读取对应的数据输出

单路排序,从磁盘读取查询需要的所有列,按照order by列在buffer对他们进行排序,然后扫描排序后的列表进行输出,它的效率更快一些,避免了第二次读取数据,并且把随机IO变成了顺序IO,但是它会使用更多的空间

优化策略调整MySQL参数

增加sort_buffer_size参数设置
增大max_lenght_for_sort_data参数的设置


9：什么是回表排序 use filesort 【双路排序（又叫回表排序模式）】

根据索引或者全表扫描，按照过滤条件获得需要查询的排序字段值和row ID；
将要排序字段值和row ID组成键值对，存入sort buffer中；
如果sort buffer内存大于这些键值对的内存，就不需要创建临时文件了。否则，每次sort buffer填满以后，需要直接用qsort(快速排序算法)在内存中排好序，并写到临时文件中；
【重复上述步骤，直到所有的行数据都正常读取了完成；
用到了临时文件的，需要利用磁盘外部排序，将row id写入到结果文件中；】use tem
根据结果文件中的row ID按序读取用户需要返回的数据。由于row ID不是顺序的，导致回表时是随机IO，为了进一步优化性能（变成顺序IO），MySQL会读一批row ID，并将读到的数据按排序字段顺序插入缓存区中(内存大小read_rnd_buffer_size)。


10：单路排序【不回表排序模式】

根据索引或者全表扫描，按照过滤条件获得需要查询的数据；
将要排序的列值和用户需要返回的字段组成键值对，存入sort buffer中；
如果sort buffer内存大于这些键值对的内存，就不需要创建临时文件了。否则，每次sort buffer填满以后，需要直接用qsort(快速排序算法)在内存中排好序，并写到临时文件中；
重复上述步骤，直到所有的行数据都正常读取了完成；
用到了临时文件的，需要利用磁盘外部排序，将排序后的数据写入到结果文件中；
直接从结果文件中返回用户需要的字段数据，而不是根据row ID再次回表查询。