1，checkpoint产生的背景【还有一个savepoint 事务】
数据库在发生增删查改操作的时候，为了提高事物操作的效率，都是先在buffer pool中完成的，buffer pool中修改之后的数据，并没有立即写入到磁盘，这有可能会导致内存中数据与磁盘中的数据产生不一致的情况。
事物要求之一是持久性（Durability），buffer pool与磁盘数据的不一致性的情况下发生故障，可能会导致数据无法持久化。
为了防止在内存中修改但尚未写入到磁盘的数据，在发生故障重启数据之后产生事物未持久化的情况，是通过日志(redo log)先行的方式来保证的。
redo log可以在故障重启之后实现“重做”，保证了事物的持久化的特性，但是redo log空间不可能无限制扩大，对于内存中已修改但尚未提交到磁盘的数据，也即脏页，也需要写入磁盘。
对于内存中的脏页，什么时候，什么情况下，将多少脏页写入磁盘，是由多方面因素决定的。
checkpoint的工作之一，就是对于内存中的脏页，在一定条件下将脏页刷新到磁盘。

checkpoint解决的问题：
1，缩短数据库的恢复时间
2，缓冲池不够用时，将脏页刷新到磁盘，释放buffer pool空间。
3，redo log不够用时，刷新脏页到磁盘，释放redo log空间。


2，checkpoint的分类
按照checkpoint刷新的方式，MySQL中的checkpoint分为两种，也即sharp checkpoint和fuzzy checkpoint。
sharp checkpoint：在关闭数据库的时候，将buffer pool中的脏页全部刷新到磁盘中。
fuzzy checkpoint：数据库正常运行时，在不同的时机，将部分脏页写入磁盘，进刷新部分脏页到磁盘，也是为了避免一次刷新全部的脏页造成的性能问题。
【
InnoDB存储引擎内部，两种checkpoint，分别为:
Sharp Checkpoint
Fuzzy Checkpoint
Sharp Checkpoint发生在数据库关闭时，将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数：innodb_fast_shutdown=1。
不适用于数据库运行时的刷新。

在数据库运行时，InnoDB存储引擎内部采用Fuzzy Checkpoint，只刷新一部分脏页。【以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘】
】

3: checkpoint解决的问题：
缩短数据库的恢复时间
缓冲池不够用，将脏页刷新回磁盘
重做日志不可用（不可被重用，不可被覆盖），刷新脏页
     1.缩短数据库恢复时间重做日志中记录了的checkpoint的位置，这个点之前的页已经刷新回磁盘，只需要对checkpoint之后的重做日志进行恢复。这样就大大缩短了恢复时间。
     2.缓冲池不够用时，根据LRU算法，溢出最近最少使用的页，如果页为脏页，强制执行checkpoint，将页刷新回磁盘。
     3.重做日志不可用，是指，重做日志的这部分不可以被覆盖，为什么？因为：这部分对应的数据还未刷新到磁盘上。重做日志的设计是循环使用的。数据库恢复时，如果不需要，即可被覆盖；如果需要，必须强制执行checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。