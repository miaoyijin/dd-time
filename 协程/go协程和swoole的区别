1：首先了解go 的runtime

提到 runtime, 大家可能会想起 java, python 的 runtime. 不过 go 和这两者不太一样,
java, python 的 runtime 是虚拟机, 而 go 的 runtime 和用户代码一起编译到一个可执行文件中.


2：go的协程给予GMP模型

1.0 是GM模型
1.1 是GMP模型



goroutine 是通过 GPM 调度模型实现的。
M: 表示内核级线程，一个 M 就是一个线程，goroutine 跑在 M 之上的。
G: 表示一个 goroutine，它有自己的栈。
P: 全称是 Processor，处理器。它主要用来执行 goroutine 的，【同时它也维护了一个goroutine 队列】。

P 队列
通过上图可以发现，P有两种队列：本地队列和全局队列
=================================================================================



3：Swoole 的协程是基于单线程的，无法利用多核 CPU，同一时间只有一个在调度（也有优势省去了加锁额开开销，因为单线程无资源竞争）
如果要多加执行速度，只能多开进程不能做到自动管理，不方便。

4：go的协程给予GMP模式是可以自动管理，根据负载情况增加，减少线程。


5：Swoole的协程是基于 setjmp 、 longjmp 实现的。



Swoole 的协程调度器，大家应该都知道吧。是属于单线程的，不存在数据同步问题，同一时间只会有一个协程去执行。 对 cpu 多核利用，需依赖于 Swoole 多进程机制。

继4.x 版本使用了 c 栈 + php 栈的协程实现方案。我们创建的 Server 程序每次请求的事件回调函数中会创建一个新协程（称之为初代协程），处理完成后协程退出。

协程创建的时候需要一个全新的内存段作为c 和 php 的栈，底层默认分配2M(c)虚拟内存+8k(php)内存，这是对于 php7.2+ 版本。

【这个 c 栈主要用于保存底层函数的调用的局部变量数据】，解决 call_user_func、array_map 等 c 函数调用在协程切换时未能还原问题。

【php 栈主要保存函数调用的局部变量数据】，主要是zval结构体，php中标量类型(整型，浮点，布尔，字符)这些是直接保存在zval结构体内，而其它的变量类型是使用引用计数去管理的，在堆上存储。

c 栈切换使用了 boost.context 1.60 汇编代码，用于保存寄存器，切换指令序列，由 jump_fcontext 这个 ASM 函数提供。

主协程即为 Reactor 协程，负责整个 EventLoop 的运行。实现事件监听，在 io 事件完成后唤醒其它工作协程。

协程挂起： 在工作协程执行一些 io 操作，底层会将 io 事件注册到 EventLoop，让出执行权



