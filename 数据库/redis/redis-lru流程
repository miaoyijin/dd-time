1:freeMemoryIfNeeded() {
 while (mem_freed < mem_tofree) {
    //循环释放直到满足需求内存

    struct evictionPoolEntry *pool = EvictionPoolLRU;//这是一个全局引用


    ==> 获取bestkey


     for (i = 0; i < server.dbnum; i++) {
                    //循环16个db删除过期key
                    evictionPoolPopulate();//EVPOOL_SIZE 默认16
                }

      //从redis evictionPool 中选择bestkey
       for (k = EVPOOL_SIZE-1; k >= 0; k--) {}

            //删除bestkey
            if (server.lazyfree_lazy_eviction)
                dbAsyncDelete(db,keyobj);
            else
                dbSyncDelete(db,keyobj);


      mem_freed++;

 }

 }


 2:evictionPoolPopulate 解析,pool 内部是排序过的过期时间从大到小，应为循环删除，所以需要排序，方便从第一个开始
evictionPoolPopulate()
{

 dictGetSomeKeys()随机获取maxmemory_samples个数据


if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
            idle = estimateObjectIdleTime(o);//获取剩余时间
 }

 memmove(pool+k+1,pool+k,
                     sizeof(pool[0])*(EVPOOL_SIZE-k-1));
                 pool[k].cached = cached; //插入排序
 }



 3： 关于EvictionPoolLRU 的说明 服务启动是初始化这个lru内存池
 initServer（）{
 evictionPoolAlloc(); /* Initialize the LRU keys pool. */

 }




4：void evictionPoolAlloc(void) {
      struct evictionPoolEntry *ep;
      int j;

      ep = zmalloc(sizeof(*ep)*EVPOOL_SIZE);
      for (j = 0; j < EVPOOL_SIZE; j++) {
          ep[j].idle = 0;
          ep[j].key = NULL;
          ep[j].cached = sdsnewlen(NULL,EVPOOL_CACHED_SDS_SIZE);
          ep[j].dbid = 0;
      }
      EvictionPoolLRU = ep;
  }



  所以缓存淘汰过程（根据lru策略分析）
  1：服务初始化执行init调用evictionPoolAlloc 初始化lru pool （size = 16数组）
  2：判断是否需要缓存淘汰策略
  3：执行 freeMemoryIfNeeded
  4：循环16个db，每个db选择maxmemory_samples个元素，根据idea（空闲时间）执行插入排序放入db lru pool中
  5：删除lru pool中最末尾的元素
  6：重复操作直到满足需求内存

