1:freeMemoryIfNeeded() {
 while (mem_freed < mem_tofree) {
    //循环释放直到满足需求内存

    struct evictionPoolEntry *pool = EvictionPoolLRU;//每次申请一个pool


    ==> 获取bestkey


     for (i = 0; i < server.dbnum; i++) {
                    //循环16个db删除过期key
                    evictionPoolPopulate();//EVPOOL_SIZE 默认16
                }

      //从redis evictionPool 中选择bestkey
       for (k = EVPOOL_SIZE-1; k >= 0; k--) {}

            //删除bestkey
            if (server.lazyfree_lazy_eviction)
                dbAsyncDelete(db,keyobj);
            else
                dbSyncDelete(db,keyobj);


      mem_freed++;

 }

 }


 2:evictionPoolPopulate 解析,pool 内部是排序过的过期时间从大到小，应为循环删除，所以需要排序，方便从第一个开始
evictionPoolPopulate()
{

 dictGetSomeKeys()随机获取maxmemory_samples个数据


if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
            idle = estimateObjectIdleTime(o);//获取剩余时间
 }

 }


