链表组成部分：每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域

一： 时间复杂度计算：
 时间复杂度
（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

大O复杂度表示法
下面有一段代码，来估算一下这段代码的执行时间：

复制代码
1 int cal(int n) {
2   int sum = 0;
3   int i = 0;
4   int j = 0;
5   for (; i < n; ++i) {
6     j = 1;
7     for (; j < n; ++j) {
8       sum = sum +  i * j;
9     }
10   }
11 }
复制代码
假设每行代码执行的时间都一样，为 unit_time，在这个假设的基础之上，我们可以看出：第 2、3、4 行代码分别需要 1 个 unit_time 的执行时间，第 5、6 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，第 7、8 行代码循环执行了 n^2遍，所以需要 2n^2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n^2+2n+3)*unit_time。

通过这段代码执行时间的推导过程，我们可以知道，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。用大 O 复杂度表示法可以这样表示：T(n) = O（f(n)）

其中，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。


二：时间复杂度分析方法
1: 只关注循环执行次数最多的一段代码
2: 加法法则：总复杂度等于量级最大的那段代码的复杂度
3: 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


三：常见时间复杂度




四：时间复杂度分类
最好情况时间复杂度（best case time complexity）、
最坏情况时间复杂度（worst case time complexity）、
平均情况时间复杂度（average case time complexity）、
均摊时间复杂度

一般说的时间复杂度值的是最坏时间复杂度