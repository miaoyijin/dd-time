Linux的4种锁机制：

互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。

自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。

RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。


重点：：：读写锁与互斥锁类似，但是并行性更高，其原因在于互斥锁每次只有一个线程可以得到锁进行操作，其余的线程都因为得不到锁而处于阻塞状态。创建多线程进行操作的本意是为了并发执行任务，但是由于互斥锁的缘故导致线程的操作变成了串行的，严重影响整个程序的运行效率。

读写锁的好处是线程根据操作类型分为两类:读线程和写线程。读线程只对共享资源进行读操作，并不改变共享资源;写操作对共享资源进行写操作，会改变共享资源。因此多个读线程可以共同占有一个读写锁，而对于写线程而言，任一时刻只能有一个写线程占有读写锁。在程序执行时，如果对共享资源作读操作的线程远远大于写线程的时候，使用这种读写锁可以大大提高线程的并发度，从而提高程序运行的效率。